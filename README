xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)).  See also https://pdos.csail.mit.edu/6.1810/, which provides
pointers to on-line resources for v6.

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by
Takahiro Aoyagi, Silas Boyd-Wickizer, Anton Burtsev, carlclone, Ian
Chen, Dan Cross, Cody Cutler, Mike CAT, Tej Chajed, Asami Doi,
eyalz800, Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel
Filardo, flespark, Peter Froehlich, Yakir Goaron, Shivam Handa, Matt
Harvey, Bryan Henry, jaichenhengjie, Jim Huang, Matúš Jókay, John
Jolly, Alexander Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller,
Jungwoo Kim, Jonathan Kimmitt, Eddie Kohler, Vadim Kolontsov, Austin
Liew, l0stman, Pavan Maddamsetti, Imbar Marinescu, Yandong Mao, Matan
Shabtay, Hitoshi Mitake, Carmi Merimovich, Mark Morrissey, mtasm, Joel
Nider, Hayato Ohhashi, OptimisticSide, Harry Porter, Greg Price, Jude
Rich, segfault, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Fumiya
Shigemitsu, Cam Tenny, tyfkda, Warren Toomey, Stephen Tu, Rafael Ubal,
Amane Uehara, Pablo Ventura, Xi Wang, WaheedHafez, Keiichi Watanabe,
Nicolas Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng,
ZhUyU1997, and Zou Chang Wei.


The code in the files that constitute xv6 is
Copyright 2006-2022 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

Please send errors and suggestions to Frans Kaashoek and Robert Morris
(kaashoek,rtm@mit.edu).  The main purpose of xv6 is as a teaching
operating system for MIT's 6.1810, so we are more interested in
simplifications and clarifications than new features.

BUILDING AND RUNNING XV6

You will need a RISC-V "newlib" tool chain from
https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
riscv64-softmmu.  Once they are installed, and in your shell
search path, you can run "make qemu".


For this lab, we need to add two system calls:
1. void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
2. munmap(addr, length)

Both syscalls are mirrored from Linux mmap and munmap. This lab only 
implements mmap and munmap for mapping files to user processes. File system 
provides processes with basic support, like fread, fwrite, and fseek, etc. With
mmap and munmap, user processes will have a more convient way to manipulate file
content just like manipulate normal memory.

To support mmap, VMA (Virtual memroy area) is needed to bookkeep the information 
on the file mapped to the process. Each process has a pre-defined fixed-size 
array of VMAs. Whenever a file is maped, the kernel will find an unused VMA to 
be allocated. If a process runs out of its VMAs, an error will return to the user.

VMA:
+-------------+
| file *f     |
+-------------+
| uint64 addr |
+-------------+
| int len     |
+-------------+
| int prot    |
+-------------+
| int flags   |
+-------------+
| int alloc   |
+-------------+

VMA includes a pointer to the file, the start address of the memory mapping the 
file, the length of mapped file, the protection info and flags.

One of the challenges is to implement lazy memory allocation. This feature 
enables mmap return instantly, which can be helpful in the case of large files.

Lazy memory allocation:
Mmap doesn't directly allocate memory for the mmaped files, it will reserve a range
of addresses, and returns to user space. Whenever the user needs to access the mmaped
memory, a fault page will happen. For load page fault, register scause will be set
to 13 and register stval stores the faulting virtual address. 
We check if this address belongs to any VMA, if so, we can allocate a page by reading one corresponding block of the file.
When mmapped memory is accessed, it's always read before writing to it. So we won't have
to handle store page fault (15).

The proper permissions on the newly allocated page needs to be set:
V-bit and  U-bit is set.
VMA: 
    PROT_READ => R-bit is set
    PROT_WRITE => W-bit is set
    PROT_NONE => none


xv6 process memory layout:
+--------------+
| free memory  | 
|    ...       | 
+--------------+
| heap         |
+--------------+
| stack        |
+--------------+
| static       |
+--------------+

after lazy allocation with mmap:
+--------------+
| free memory  | 
|    ...       | 
+--------------+
| reserved VAs |  <= a corresponding VMA will be allocated to bookkeep the metadata
+--------------+
| heap         |
+--------------+
| stack        |
+--------------+
| static       |
+--------------+

mmap:
Add the following VMA-related fields to struct proc. The file being mmapped must
be incremented by on their reference count to avoid the file struct being freed
while being used by some mmapped processes. When a process is forked, the child
process will have copy all the VMAs from its parent, but the physical page mmaped
are different in this implemtation. (which can be optimized by using the same physical
memory on parent and child processes, it will enable them to see the updates 
from each other.)

+----------------+
| ...            |
+----------------+
| VMA vmas[16]   |
+----------------+
| VMA* vmasp[16] |
+----------------+
| uint vma_count |
+----------------+

munmap:
The unmmap always starts from the start or the end of an VMA. We only need to update
the length of VMA and the starting position. If the entire VMA is removed, then we
need to decrement the reference count of the corresponding file. If the VMA has flags
set to be MAP_SHARED, the modified page is written back to disk. It is done
by going through all the pages needed to be freed and check if the dirty bit is set.
On the other hand, if VMA is privately mmaped, the changes are discarded.
